#!/usr/bin/env python

Import("env")

android_files = [
    "os_android.cpp",
    "android_input_handler.cpp",
    "file_access_android.cpp",
    "audio_driver_opensl.cpp",
    "android_jni_dir_access.cpp",
    "thread_jandroid.cpp",
    "net_socket_android.cpp",
    "android_jni.cpp",
    "java_class_wrapper.cpp",
    "android_jni_os.cpp",
    "android_jni_io.cpp",
    "jni_utils.cpp",
    "android_keys_utils.cpp",
    "android_jni_plugin.cpp",
]

env_android = env.Clone()

android_objects = []
for x in android_files:
    android_objects.append(env_android.SharedObject(x))

env_thirdparty = env_android.Clone()
env_thirdparty.disable_warnings()
thirdparty_obj = env_thirdparty.SharedObject("#thirdparty/misc/ifaddrs-android.cc")
android_objects.append(thirdparty_obj)

lib = env_android.add_shared_library(
    "#bin/librebel", [android_objects], SHLIBSUFFIX=env["SHLIBSUFFIX"]
)

# Needed to force rebuilding the platform files when the thirdparty code is updated.
env.Depends(lib, thirdparty_obj)

lib_arch_dir = ""
if env["android_arch"] == "armv7":
    lib_arch_dir = "armeabi-v7a"
elif env["android_arch"] == "arm64v8":
    lib_arch_dir = "arm64-v8a"
elif env["android_arch"] == "x86":
    lib_arch_dir = "x86"
elif env["android_arch"] == "x86_64":
    lib_arch_dir = "x86_64"
else:
    print(
        "WARN: Architecture not suitable for embedding into APK; keeping .so at \\bin"
    )

if lib_arch_dir != "":
    if env["target"] == "release":
        lib_type_dir = "release"
    else:  # release_debug, debug
        lib_type_dir = "debug"

    out_dir = (
        "#platform/android/project/engine/libs/" + lib_type_dir + "/" + lib_arch_dir
    )
    env_android.Command(
        out_dir + "/librebel_android.so",
        "#bin/librebel" + env["SHLIBSUFFIX"],
        Copy("$TARGET", "$SOURCE"),
    )
    env_android.Command(
        out_dir + "/libc++_shared.so", env["LIBC"], Copy("$TARGET", "$SOURCE")
    )
